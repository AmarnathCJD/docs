---
title: "CallbackQuery"
description: "Handle button clicks and callback queries"
---

<Note>
  To use inline buttons with callback data, you need to enable inline mode for your bot. Go to [@BotFather](https://t.me/BotFather), select your bot, go to **Bot Settings** ‚Üí **Inline Mode** and turn it on.
</Note>

## Overview

`CallbackQuery` represents a callback from an inline button click. It's triggered when users click inline keyboard buttons with callback data.

## Structure

```go
type CallbackQuery struct {
    QueryID        int64
    Data           []byte
    OriginalUpdate *UpdateBotCallbackQuery
    Sender         *UserObj
    MessageID      int32
    SenderID       int64
    ChatID         int64
    Chat           *ChatObj
    Channel        *Channel
    Peer           Peer
    Client         *Client
}
```

## Basic Properties

### Query Information

<ParamField path="QueryID" type="int64">
  Unique query identifier
  
  ```go
  queryID := c.QueryID
  ```
</ParamField>

<ParamField path="Data" type="[]byte">
  Callback data from button
  
  ```go
  data := c.Data
  ```
</ParamField>

<ParamField path="DataString()" type="string">
  Get callback data as string
  
  ```go
  dataStr := c.DataString()
  ```
</ParamField>

<ParamField path="MessageID" type="int32">
  ID of message with the button
  
  ```go
  msgID := c.MessageID
  ```
</ParamField>

### Sender Information

<ParamField path="GetSenderID()" type="int64">
  Get user ID who clicked button
  
  ```go
  userID := c.GetSenderID()
  ```
</ParamField>

<ParamField path="GetSender()" type="(*UserObj, error)">
  Get full sender object
  
  ```go
  sender, err := c.GetSender()
  fmt.Println(sender.FirstName)
  ```
</ParamField>

### Chat Information

<ParamField path="GetChatID()" type="int64">
  Get chat/channel ID
  
  ```go
  chatID := c.GetChatID()
  ```
</ParamField>

<ParamField path="ChatType()" type="string">
  Get chat type: `user`, `chat`, `channel`
  
  ```go
  if c.ChatType() == telegram.EntityUser {
      // Private chat
  }
  ```
</ParamField>

## Answer Callback

### Basic Answer

<CodeGroup>

```go Simple Answer
// Answer with popup message
c.Answer("Button clicked!", &telegram.CallbackOptions{
    Alert: false, // Toast notification
})
```

```go Alert Answer
// Answer with alert popup
c.Answer("Operation successful!", &telegram.CallbackOptions{
    Alert: true, // Alert dialog
})
```

```go URL Answer
// Answer with URL to open
c.Answer("", &telegram.CallbackOptions{
    URL: "https://example.com",
})
```

```go Cache Time
// Answer with custom cache time
c.Answer("Cached response", &telegram.CallbackOptions{
    CacheTime: 300, // Cache for 5 minutes
})
```

</CodeGroup>

## Response Methods

### Edit Message

<Tabs>
  <Tab title="Edit Text">
    ```go
    // Edit message text
    c.Edit("Button was clicked!")
    
    // Edit with options
    keyboard := telegram.NewKeyboard()
    keyboard.AddRow(telegram.Button.Data("New Button", "new_data"))
    
    c.Edit("Updated text", &telegram.SendOptions{
        ParseMode: "HTML",
        ReplyMarkup: keyboard,
    })
    ```
  </Tab>
  <Tab title="Edit Markup">
    ```go
    // Change only buttons
    keyboard := telegram.NewKeyboard()
    keyboard.AddRow(telegram.Button.Data("Updated", "updated"))
    
    c.Edit("Same text", &telegram.SendOptions{
        ReplyMarkup: keyboard,
    })
    ```
  </Tab>
  <Tab title="Remove Markup">
    ```go
    // Remove buttons
    c.Edit("Buttons removed", &telegram.SendOptions{
        ReplyMarkup: &telegram.ReplyKeyboardRemove{},
    })
    ```
  </Tab>
</Tabs>

### Send Messages

<CodeGroup>

```go Reply
// Reply to the message with button
msg, err := c.Reply("Replying to your click")
```

```go Respond
// Send new message without replying
msg, err := c.Respond("Processing...")
```

```go Reply Media
// Reply with media
c.ReplyMedia(&telegram.InputMediaPhoto{
    File: "photo.jpg",
}, &telegram.MediaOptions{
    Caption: "Here's your photo",
})
```

```go Respond Media
// Send media without replying
c.RespondMedia(&telegram.InputMediaVideo{
    File: "video.mp4",
})
```

</CodeGroup>

## Message Operations

### Get Message

```go
// Get the message that has the button
msg, err := c.GetMessage()
if err == nil {
    fmt.Println("Message text:", msg.Text())
}
```

### Delete Message

```go
// Delete message with button
affected, err := c.Delete()
if err == nil {
    fmt.Println("Message deleted")
}
```

### Forward Message

```go
// Forward message to another chat
msg, err := c.ForwardTo(targetChatID, &telegram.ForwardOptions{
    Silent: true,
})
```

## Chat Type Checks

<Tabs>
  <Tab title="Private">
    ```go
    if c.IsPrivate() {
        c.Answer("Private chat callback")
    }
    ```
  </Tab>
  <Tab title="Group">
    ```go
    if c.IsGroup() {
        c.Answer("Group chat callback")
    }
    ```
  </Tab>
  <Tab title="Channel">
    ```go
    if c.IsChannel() {
        c.Answer("Channel callback")
    }
    ```
  </Tab>
</Tabs>

## Advanced Features

### Conversations

<CodeGroup>

```go Ask Question
// Start conversation after callback
response, err := c.Ask("What's your name?")
if err == nil {
    c.Respond("Hello, " + response.Text())
}
```

```go Manual Conversation
// Manual conversation handling
conv, _ := c.Conv(120) // 120 sec timeout
defer conv.Close()

conv.Respond("Enter your age:")
age, _ := conv.GetResponse()

conv.Respond("Enter your city:")
city, _ := conv.GetResponse()

c.Answer(fmt.Sprintf("Age: %s, City: %s", 
    age.Text(), city.Text()))
```

</CodeGroup>

### Get Related Objects

```go
// Get chat object
chat, err := c.GetChat()

// Get channel object
channel, err := c.GetChannel()

// Get sender user
sender, err := c.GetSender()
```

## Practical Examples

### Button Navigation

```go
client.On("callback", func(c *telegram.CallbackQuery) error {
    data := c.DataString()
    
    switch data {
    case "menu_main":
        keyboard := telegram.NewKeyboard()
        keyboard.AddRow(
            telegram.Button.Data("üìù Help", "menu_help"),
            telegram.Button.Data("‚ÑπÔ∏è About", "menu_about"),
        )
        
        c.Edit("Main Menu", &telegram.SendOptions{
            ReplyMarkup: keyboard,
        })
        c.Answer("Main menu opened")
        
    case "menu_help":
        keyboard := telegram.NewKeyboard()
        keyboard.AddRow(telegram.Button.Data("¬´ Back", "menu_main"))
        
        c.Edit("Help Section\n\nCommands:\n/start\n/help", 
            &telegram.SendOptions{
                ReplyMarkup: keyboard,
            })
        c.Answer("Help")
        
    case "menu_about":
        keyboard := telegram.NewKeyboard()
        keyboard.AddRow(telegram.Button.Data("¬´ Back", "menu_main"))
        
        c.Edit("About Bot\n\nVersion 1.0", &telegram.SendOptions{
            ReplyMarkup: keyboard,
        })
        c.Answer("About")
    }
    
    return nil
})
```

### Confirmation Dialog

```go
client.On("callback:delete_", func(c *telegram.CallbackQuery) error {
    data := c.DataString()
    
    if data == "delete_confirm" {
        c.Delete()
        c.Answer("Message deleted!", &telegram.CallbackOptions{
            Alert: true,
        })
    } else if data == "delete_cancel" {
        c.Edit("Deletion cancelled")
        c.Answer("Cancelled")
    }
    
    return nil
})

// Initial message with confirmation
client.On("cmd:delete", func(m *telegram.NewMessage) error {
    keyboard := telegram.NewKeyboard()
    keyboard.AddRow(
        telegram.Button.Data("‚úÖ Yes", "delete_confirm"),
        telegram.Button.Data("‚ùå No", "delete_cancel"),
    )
    
    m.Reply("Are you sure?", telegram.SendOptions{
        ReplyMarkup: keyboard,
    })
    return nil
})
```

### Pagination

```go
client.On("callback:page_", func(c *telegram.CallbackQuery) error {
    data := c.DataString()
    page := 1
    
    // Parse page number from data
    fmt.Sscanf(data, "page_%d", &page)
    
    // Get items for page
    items := getItemsForPage(page)
    
    // Build message
    text := fmt.Sprintf("Page %d\n\n%s", page, items)
    
    // Build pagination buttons
    keyboard := telegram.NewKeyboard()
    
    row := []telegram.Button{}
    if page > 1 {
        row = append(row, telegram.Button.Data("¬´ Prev", fmt.Sprintf("page_%d", page-1)))
    }
    row = append(row, telegram.Button.Data(fmt.Sprintf("¬∑ %d ¬∑", page), "page_current"))
    row = append(row, telegram.Button.Data("Next ¬ª", fmt.Sprintf("page_%d", page+1)))
    
    keyboard.Row(row...)
    
    c.Edit(text, &telegram.SendOptions{
        ReplyMarkup: keyboard,
    })
    c.Answer(fmt.Sprintf("Page %d", page))
    
    return nil
})
```

### Admin Actions

```go
adminIDs := []int64{123456789, 987654321}

client.On("callback:admin_", func(c *telegram.CallbackQuery) error {
    // Check if user is admin
    isAdmin := false
    for _, id := range adminIDs {
        if c.GetSenderID() == id {
            isAdmin = true
            break
        }
    }
    
    if !isAdmin {
        c.Answer("Access denied!", &telegram.CallbackOptions{
            Alert: true,
        })
        return nil
    }
    
    data := c.DataString()
    
    switch data {
    case "admin_ban":
        // Ban user
        c.Answer("User banned", &telegram.CallbackOptions{
            Alert: true,
        })
        
    case "admin_delete":
        // Delete message
        c.Delete()
        c.Answer("Deleted")
        
    case "admin_warn":
        // Warn user
        c.Answer("User warned", &telegram.CallbackOptions{
            Alert: true,
        })
    }
    
    return nil
})
```

### Loading States

```go
client.On("callback:process", func(c *telegram.CallbackQuery) error {
    // Show loading
    c.Edit("Processing... ‚è≥")
    c.Answer("Please wait...")
    
    // Do some work
    time.Sleep(2 * time.Second)
    
    // Show result
    keyboard := telegram.NewKeyboard()
    keyboard.AddRow(telegram.Button.Data("Do Again", "process"))
    
    c.Edit("‚úÖ Complete!", &telegram.SendOptions{
        ReplyMarkup: keyboard,
    })
    c.Answer("Done!")
    
    return nil
})
```

### Data with Parameters

```go
client.On("callback:action_", func(c *telegram.CallbackQuery) error {
    data := c.DataString()
    
    // Parse action and parameter
    // Format: "action_TYPE_PARAM"
    parts := strings.Split(data, "_")
    if len(parts) < 3 {
        return nil
    }
    
    action := parts[1]
    param := parts[2]
    
    switch action {
    case "like":
        c.Answer(fmt.Sprintf("Liked item %s", param))
        
    case "share":
        c.Answer(fmt.Sprintf("Shared item %s", param))
        
    case "delete":
        c.Answer(fmt.Sprintf("Deleted item %s", param), 
            &telegram.CallbackOptions{Alert: true})
    }
    
    return nil
})
```

## Complete Example

```go
package main

import (
    "fmt"
    "github.com/amarnathcjd/gogram/telegram"
)

func main() {
    client, _ := telegram.NewClient(telegram.ClientConfig{
        AppID: 6, AppHash: "app_hash",
    })
    
    client.LoginBot("bot_token")
    
    // Send button
    client.On("cmd:start", func(m *telegram.NewMessage) error {
        keyboard := telegram.NewKeyboard()
        keyboard.AddRow(
            telegram.Button.Data("üëç Like", "action_like"),
            telegram.Button.Data("‚ù§Ô∏è Love", "action_love"),
        )
        keyboard.AddRow(
            telegram.Button.Data("‚ÑπÔ∏è Info", "action_info"),
        )
        
        m.Reply("Welcome! Click a button:", telegram.SendOptions{
            ReplyMarkup: keyboard,
        })
        return nil
    })
    
    // Handle callbacks
    client.On("callback", func(c *telegram.CallbackQuery) error {
        data := c.DataString()
        sender, _ := c.GetSender()
        
        fmt.Printf("Callback from %s: %s\n", 
            sender.FirstName, data)
        
        switch data {
        case "action_like":
            c.Answer("You clicked Like! üëç")
            c.Edit("You liked this message! üëç")
            
        case "action_love":
            c.Answer("You clicked Love! ‚ù§Ô∏è", 
                &telegram.CallbackOptions{Alert: true})
            c.Edit("You loved this message! ‚ù§Ô∏è")
            
        case "action_info":
            keyboard := telegram.NewKeyboard()
            keyboard.AddRow(telegram.Button.Data("¬´ Back", "action_back"))
            
            c.Edit("Bot Info\n\nVersion 1.0\nBy @YourBot", 
                &telegram.SendOptions{
                    ReplyMarkup: keyboard,
                })
            c.Answer("Info")
            
        case "action_back":
            keyboard := telegram.NewKeyboard()
            keyboard.AddRow(
                telegram.Button.Data("üëç Like", "action_like"),
                telegram.Button.Data("‚ù§Ô∏è Love", "action_love"),
            )
            keyboard.AddRow(
                telegram.Button.Data("‚ÑπÔ∏è Info", "action_info"),
            )
            
            c.Edit("Welcome! Click a button:", telegram.SendOptions{
                ReplyMarkup: keyboard,
            })
            c.Answer("Main menu")
        }
        
        return nil
    })
    
    client.Idle()
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="NewMessage" icon="message" href="/handlers/updates/newmessage">
    Learn about messages
  </Card>
  <Card title="Album" icon="images" href="/handlers/updates/album">
    Handle media groups
  </Card>
  <Card title="InlineQuery" icon="search" href="/handlers/updates/inline">
    Handle inline queries
  </Card>
  <Card title="Filters" icon="filter" href="/handlers/filters">
    Filter callbacks
  </Card>
</CardGroup>
