---
title: "Update Types"
description: "Understanding different update types in Gogram"
---

## Overview

Telegram sends various types of updates for different events. Gogram provides convenient wrappers for common updates and allows handling raw updates for advanced use cases.

## Message Updates

### NewMessage

Represents incoming messages:

```go
client.On("message", func(m *telegram.NewMessage) error {
    fmt.Printf("Message from %d: %s\n", m.SenderID(), m.Text())
    
    // Common methods
    m.Reply("Got your message!")
    m.Respond("Response text")
    m.Edit("New text")
    m.Delete()
    
    return nil
})
```

**Available Methods:**
- `m.Text()` - Get message text
- `m.SenderID()` - Get sender user ID
- `m.ChatID()` - Get chat ID
- `m.ChannelID()` - Get channel ID
- `m.IsPrivate()` - Check if private chat
- `m.IsGroup()` - Check if group chat
- `m.IsChannel()` - Check if channel
- `m.IsMedia()` - Check if has media
- `m.IsCommand()` - Check if is command
- `m.IsReply()` - Check if is reply
- `m.IsForward()` - Check if is forwarded
- `m.Media()` - Get media content
- `m.Photo()` - Get photo
- `m.Video()` - Get video
- `m.Document()` - Get document
- `m.Reply(text)` - Reply to message
- `m.Respond(text)` - Send message to same chat
- `m.Edit(text)` - Edit message
- `m.Delete()` - Delete message

### EditMessage

Represents edited messages:

```go
client.On("edit", func(m *telegram.NewMessage) error {
    fmt.Printf("Message %d was edited\n", m.ID)
    return nil
})
```

### DeleteMessage

Represents deleted messages:

```go
client.On("delete", func(d *telegram.DeleteMessage) error {
    fmt.Printf("Messages deleted: %v\n", d.Messages)
    return nil
})
```

**Available Fields:**
- `d.Messages` - List of deleted message IDs
- `d.ChatID()` - Chat ID where messages were deleted
- `d.ChannelID()` - Channel ID (if deleted in channel)

### Album

Represents grouped media messages:

```go
client.On("album", func(a *telegram.Album) error {
    fmt.Printf("Album with %d items\n", len(a.Messages))
    
    for i, msg := range a.Messages {
        fmt.Printf("Item %d: %s\n", i+1, msg.MediaType())
    }
    
    return nil
})
```

**Available Fields:**
- `a.Messages` - Slice of messages in album
- `a.GroupedID` - Grouped media ID
- `a.Client` - Client instance

## Callback Updates

### CallbackQuery

Represents button callbacks:

```go
client.On("callback", func(c *telegram.CallbackQuery) error {
    fmt.Printf("Callback data: %s\n", string(c.Data))
    
    c.Answer("Received!", &telegram.AnswerCallbackQueryParams{
        Alert: true,
    })
    
    // Edit message with callback
    c.Edit("Button was clicked!")
    
    return nil
})
```

**Available Methods:**
- `c.Answer(text, params)` - Answer callback query
- `c.Edit(text)` - Edit message that has the button
- `c.Respond(text)` - Send new message
- `c.Data` - Callback data bytes
- `c.SenderID()` - User who clicked button
- `c.MessageID()` - Message ID with button
- `c.IsPrivate()` - Check if from private chat
- `c.IsGroup()` - Check if from group
- `c.IsChannel()` - Check if from channel

### InlineCallbackQuery

Represents callbacks from inline messages:

```go
client.On("inlinecallback", func(c *telegram.InlineCallbackQuery) error {
    c.Answer("Inline callback received!")
    return nil
})
```

## Inline Updates

### InlineQuery

Represents inline queries:

```go
client.On("inline", func(q *telegram.InlineQuery) error {
    fmt.Printf("Inline query: %s\n", q.Query)
    
    results := []telegram.InputBotInlineResult{
        &telegram.InputBotInlineResultObj{
            ID:    "1",
            Type:  "article",
            Title: "Result 1",
            SendMessage: &telegram.InputBotInlineMessageText{
                Message: "Result content",
            },
        },
    }
    
    q.Answer(results)
    return nil
})
```

**Available Methods:**
- `q.Answer(results)` - Answer inline query
- `q.Query` - Query text
- `q.Offset` - Pagination offset
- `q.Sender` - User who sent query

### InlineSend

Represents chosen inline results:

```go
client.On("choseninline", func(s *telegram.InlineSend) error {
    fmt.Printf("User chose result: %s\n", s.ID)
    return nil
})
```

## Participant Updates

### ParticipantUpdate

Represents channel participant changes:

```go
client.On("participant", func(p *telegram.ParticipantUpdate) error {
    fmt.Printf("User %d joined/left channel %d\n", p.UserID, p.ChannelID)
    return nil
})
```

**Available Fields:**
- `p.ChannelID` - Channel ID
- `p.UserID` - User ID
- `p.Date` - Update date
- `p.ActorID` - Who made the change
- `p.PrevParticipant` - Previous participant status
- `p.NewParticipant` - New participant status

### JoinRequestUpdate

Represents pending join requests:

```go
client.On("joinrequest", func(j *telegram.JoinRequestUpdate) error {
    fmt.Printf("Join requests: %d\n", j.RecentRequestersCount)
    return nil
})
```

## Raw Updates

### Handling Raw Updates

For advanced use cases, handle raw Telegram updates:

```go
client.On("raw", func(u telegram.Update, c *telegram.Client) error {
    switch update := u.(type) {
    case *telegram.UpdateNewMessage:
        // Handle raw new message
    case *telegram.UpdateUserTyping:
        // Handle typing indicator
    case *telegram.UpdateReadHistoryInbox:
        // Handle read history
    default:
        c.Log.Debug("Unhandled update: %T", update)
    }
    return nil
})
```

### Specific Raw Update Types

```go
// Handle specific update type
client.AddRawHandler(&telegram.UpdateUserTyping{}, func(u telegram.Update, c *telegram.Client) error {
    typing := u.(*telegram.UpdateUserTyping)
    fmt.Printf("User %d is typing\n", typing.UserID)
    return nil
})
```

## Common Raw Update Types

| Update Type | Description |
|-------------|-------------|
| `UpdateNewMessage` | New message received |
| `UpdateEditMessage` | Message edited |
| `UpdateDeleteMessages` | Messages deleted |
| `UpdateUserTyping` | User is typing |
| `UpdateChatUserTyping` | User typing in chat |
| `UpdateUserStatus` | User status changed |
| `UpdateReadHistoryInbox` | Inbox history read |
| `UpdateReadHistoryOutbox` | Outbox history read |
| `UpdateChannelTooLong` | Channel updates gap |
| `UpdateNewChannelMessage` | New channel message |
| `UpdateEditChannelMessage` | Channel message edited |

## Update Processing

### Groups and Priority

```go
// High priority handler (runs first)
handle1 := client.On("message", handler1)
handle1.SetPriority(10)

// Medium priority
handle2 := client.On("message", handler2)
handle2.SetPriority(5)

// Default priority (runs last)
handle3 := client.On("message", handler3)
```

### Sequential vs Concurrent

```go
// Sequential (group 1)
handle := client.On("message", handler)
handle.SetGroup(1)

// Concurrent (group 0 - default)
handle := client.On("message", handler)
handle.SetGroup(0)

// Conversation group (runs first, sequential)
handle := client.On("message", handler)
handle.SetGroup(telegram.ConversationGroup)
```

### Stopping Propagation

```go
client.On("cmd:admin", func(m *telegram.NewMessage) error {
    if m.SenderID() != adminID {
        m.Reply("Access denied")
        return telegram.EndGroup // Stop other handlers
    }
    
    // Continue to other handlers
    return nil
})
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Use Typed Updates" icon="shield-check">
    Prefer typed updates (NewMessage, CallbackQuery) over raw updates
  </Card>
  <Card title="Handle Errors" icon="triangle-exclamation">
    Always check and handle errors in update handlers
  </Card>
  <Card title="Use Filters" icon="filter">
    Filter updates early to avoid unnecessary processing
  </Card>
  <Card title="Raw Updates for Advanced" icon="code">
    Use raw updates only when typed updates don't suffice
  </Card>
  <Card title="Set Priorities" icon="arrow-up-1-9">
    Use priorities to control handler execution order
  </Card>
  <Card title="Stop When Needed" icon="hand">
    Return EndGroup to prevent unnecessary handler execution
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Event Handlers" icon="bolt" href="/handlers">
    Back to event handlers
  </Card>
  <Card title="Filters" icon="filter" href="/handlers/filters">
    Learn about filtering
  </Card>
  <Card title="Examples" icon="code" href="/examples">
    See practical examples
  </Card>
</CardGroup>
